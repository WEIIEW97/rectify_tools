Rectify_tools README
===================

This project contains two functional parts: generating LUT for a designed resolution and rectifying images by this generated LUT.

- [Rectify_tools README](#rectify_tools-readme)
  - [LUT Generation](#lut-generation)
  - [LUTParser](#lutparser)
    - [Loading LUT file](#loading-lut-file)
    - [Parsing LUT file](#parsing-lut-file)
  - [Rectify image by LUT](#rectify-image-by-lut)
    - [Algorithm Brief](#algorithm-brief)


## LUT Generation
In our algorithm of generating LUT, the designed information and structure would be:
* Header Part.(fixed length)
* Sampled x coordinates in original images.
* Sampled y coordinates in original images.
* Sampled x coordinates in rectification images.
* Sampled y coordinates in rectification images.
* Sparse delta lut from original to rectification.
* Saprse delta lut from rectification to original.

## LUTParser

### Loading LUT file 
Storing order in LUT: 
* `[1:3]` cpu_info, image cols, image rows
* `[4:7]` rect2raw_sample_rows, rect2raw_sample_cols, raw2rect_sample_rows, raw2rect_sample_cols
* `[8:11]` crop_start_x, crop_start_y, crop_end_x, crop_end_y
* `[15:i]` raw2rect_sample_x
  * raw2rect_sample_x = LUT[indices] / 2.0
  * i = 15+raw2rect_sample_col_num-1
* `[i+1:i+1+j]` raw2rect_sample_y
  * raw2rect_sample_y = LUT[indices] / 2.0
  * j = 15+raw2rect_sample_col_num+raw2rect_sample_row_num-1
* `[j+1:j+1+k]` raw2rect_delta_sample
  * k = raw2rect_sample_row_num * raw2rect_sample_col_num - 1
* `[k+1:k+1+h]` rect2raw_delta_sample
  * h = rect2raw_sample_row_num * rect2raw_sample_col_num - 1


### Parsing LUT file
By parsing the information stored in the LUT, the corresponding raw2rect/rect2raw comparison relationship is obtained
* Get rec2rawSampleX/rec2rawSampleY, raw2recSampleX/raw2recSampleY from LUT according to index
* Get raw2rect_delta_sample_x/raw2rect_delta_sample_y, rect2raw_delta_sample_x/rect2raw_delta_sample_y from LUT according to index
* Accoring to$I_{n}(x_n,y_n,t_n)=I_{n-1}(x_{n-1},y_{n-1},t_{n-1})+\Delta I$ 
  * raw2rectMap = raw2rectSample - raw2rect_delta_sample
  * rect2rawMap = rect2rawSample - rect2raw_delta_sample
* Convert raw2rectMap/rect2rawMap from sparse martix to dense matrix
  * At this time, Bilinear Interpolation is used to do coordinate interpolation
  * dense_martix = Sparse2Dense(sparse_matrix)



## Rectify image by LUT 
Pass in {Raw2RectDenseMapX, Raw2RectDenseMapY, Rect2RawDenseMapX, Rect2RawDenseMapY} and the original Yx3C image generated by *LUTParser* to produce rectified image components

### Algorithm Brief
* Initialize a uint8 matrix of the same size as orig_img
* Splicing the transpose of xOrig2Rect/yOrig2Rect together through hconcat, traverse each point in each line (assuming scale=1 at this time)
* If there is a crop operation, then only the pixels in the crop area are operated
* Return to the pixel in the crop area to find the value in the original raw2rect and write it
* Pixel weight filling with Bilinear Interpolation
* get rectfied image